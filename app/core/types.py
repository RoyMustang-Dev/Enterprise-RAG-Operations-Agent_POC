"""
Enterprise Primitive Typings Library

This module defines the strict, immutable Pydantic data contracts used globally across the 
Vertical Slice Architecture. By strictly typing the state objects here, we ensure that:
1. The API Layer
2. The Agent Logic Layer
3. The Database Persistence Layer
...all communicate using guaranteed identical dictionary structures, preventing `KeyError` crashes.

Usage:
    from app.core.types import AgentState, LogRecord
"""
from typing import TypedDict, Annotated, List, Dict, Optional, Any
from pydantic import BaseModel, Field

# -----------------------------------------------------------------------------
# 1. LangGraph Core State Dictionary schema
# -----------------------------------------------------------------------------
class OptimizationMetrics(TypedDict, total=False):
    """
    Sub-dictionary tracking specific optimizations applied during a single LLM execution.
    These are exposed to the UI for extreme observability.
    """
    temperature: float
    reasoning_effort: str
    agent_routed: str
    cache_hit: bool

class AgentState(TypedDict):
    """
    The Master Immutable State Dictionary passed between LangGraph agent nodes.
    This effectively acts as the short-term working memory of the orchestrator.
    Every agent mutates this state dictionary, and the final result is emitted to the FastAPI route.
    """
    # System Inputs
    query: str
    chat_history: List[Dict[str, str]]
    streaming_callback: Optional[Any]
    
    # Supervisor Classifications
    intent: Optional[str]               # 'rag', 'smalltalk', 'analytical'
    
    # Retrieval Mechanics
    search_query: Optional[str]         # The "Magic Prompt" rewritten query
    context_chunks: List[Dict[str, Any]] # The raw dictionaries grabbed from Qdrant Vector Store
    context_text: str                   # The formatted string block containing cited context
    
    # Evaluation Mechanics
    confidence: float                   # 0.00 to 1.00 numeric confidence of the answer
    verifier_verdict: str               # e.g., 'SUPPORTED', 'UNSUPPORTED'
    is_hallucinated: bool               # Boolean strict flag toggled by the verifier layer
    
    # Internal Observability Trace
    optimizations: OptimizationMetrics
    
    # Final Output Outputs
    answer: str
    sources: List[Dict[str, Any]]


# -----------------------------------------------------------------------------
# 2. Pydantic Observability Schemas
# -----------------------------------------------------------------------------
class TelemetryLogRecord(BaseModel):
    """
    Rigid structural definition for Enterprise Audit Logs.
    Every single complete request must emit this object perfectly to the JSONL data store.
    """
    timestamp: str = Field(description="ISO 8601 UTC execution time string.")
    session_id: str = Field(description="Unique UUID spanning a multi-turn conversation.")
    user_id: str = Field(default="anonymous_user", description="Identity hook for future auth layers.")
    
    query: str = Field(description="The exact raw string emitted by the frontend user.")
    intent_detected: str = Field(description="The routing path established by the Supervisor Agent.")
    routed_agent: str = Field(description="The final execution brain logic file utilized (e.g. RAGAgent).")
    
    latency_ms: float = Field(default=0.0, description="End-to-end execution timer in milliseconds.")
    retrieval_time_ms: float = Field(default=0.0, description="Time spent interacting with the Vector Database.")
    rerank_time_ms: float = Field(default=0.0, description="Time spent computing Cross-Encoder filtration bounds.")
    llm_time_ms: float = Field(default=0.0, description="Time blocked waiting on external Groq/Sarvam API executions.")
    
    tokens_input: int = Field(default=0, description="Inbound token count sent to primary reasoner.")
    tokens_output: int = Field(default=0, description="Outbound semantic tokens emitted by primary reasoner.")
    
    verifier_score: float = Field(default=0.0, description="Confidence threshold generated by the independence check.")
    hallucination_score: bool = Field(default=False, description="Strict boolean toggle identifying unsourced logical jumps.")
    
    hardware_used: str = Field(default="cpu", description="Records 'cuda', 'mps', or 'cpu' dynamically.")
    temperature_used: float = Field(default=0.4, description="Records the exact heat signature of the LLM execution.")
